% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/patch-class.R
\name{patch}
\alias{area}
\alias{area<-}
\alias{features}
\alias{features<-}
\alias{is.patch}
\alias{patch}
\alias{population}
\alias{population<-}
\alias{print.patch}
\title{patch objects}
\usage{
patch(patch_data)

is.patch(x)

\method{print}{patch}(x, ...)

area(patch)

area(patch) <- value

population(patch)

population(patch) <- value

features(patch)

features(patch) <- value
}
\arguments{
\item{patch_data}{an object to turn into a \code{patch} object. Currently
this can either be a dynamic, a list or \code{NULL} (see \code{details}),
though more approaches will be added in the future}

\item{x}{an object to print or test as a patch object}

\item{patch}{an object of class \code{patch}}

\item{value}{the value to assign to the \code{area}, \code{population}, or
\code{features} elements of \code{patch}}

\item{\dots}{further arguments passed to or from other methods.}
}
\value{
an object of class \code{patch}, with elements \code{area},
  \code{population}, \code{features} providing information about a habitat
  patch
}
\description{
\code{patch} objects represent patches in a metapopulation,
  storing information (such as area, population and environmental features)
  that may impact on the dynamic transitions occurring in that patch
}
\details{
\code{patch_data} can be a list containing the following elements:
  \code{population}, a named numeric vector giving the number of individuals
  of each stage *within the patch*; \code{area}; a single numeric value
  giving the area of the patch in square kilometres; and \code{features}, a
  named numeric vector containing miscellaneous features of the habitat
  patch, such and measures of patch quality or environmental variables.
  Alternatively, \code{patch_data = NULL}, will set up a 'default' patch with
  \code{area = 1} and blank \code{population} and \code{features} elements.
  The other option is to pass a \code{dynamic} object as \code{patch_data},
  in which case the set up will be the same as for \code{patch_data = NULL}
  except that \code{population} will be a named vector of 0s, with the names
  giving the states contained in the dynamic. This is what's used in
  analysing a \code{dynamic} object without metapopulation structure.

the accessor functions \code{area}, \code{population} and
  \code{features} either return or set the elements of the same name in a
  \code{patch} object
}
\examples{
# create a default patch
patch <- patch(NULL)

# create a more interesting patch
patch <- patch(list(area = 10,
                    population = c(adult = 10, larva = 3, egg = 20),
                    features = c(temperature = 10)))
# print method
print(patch)

# get and set the area
area(patch)
area(patch) <- 2
area(patch)

# get and set the population
population(patch)
population(patch) <- population(patch) * 2
population(patch)

# get and set the features
features(patch)
features(patch) <- c(features(patch), rainfall = 100)
features(patch)

}

