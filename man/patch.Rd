% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/patch-class.R
\name{patch}
\alias{is.patch}
\alias{patch}
\alias{print.patch}
\title{patch objects}
\usage{
patch(patch_data)

is.patch(x)

\method{print}{patch}(x, ...)
}
\arguments{
\item{patch_data}{an object to turn into a \code{patch} object. Currently
this can either be a list or NULL (see \code{details}), though more
approaches will be added in the future}

\item{x}{an object to print or test as a patch object}

\item{\dots}{further arguments passed to or from other methods.}
}
\value{
an object of class \code{patch}, with elements \code{area},
  \code{population}, \code{features} providing information about a habitat
  patch
}
\description{
\code{patch} objects represent patches in a metapopulation,
  storing information (such as area, population and environmental features)
  that may impact on the dynamic transitions occurring in that patch
}
\details{
\code{patch_data} can be a list containing the following elements:
  \code{population}, a named numeric vector giving the number of individuals
  of each stage *within the patch*; \code{area}; a single numeric value
  giving the area of the patch in square kilometres; and \code{features}, a
  named numeric vector containing miscellaneous features of the habitat
  patch, such and measures of patch quality or environmental variables.
  Alternatively, \code{patch_data = NULL}, will set up a 'default' patch with
  \code{area = 1} and blank \code{population} and \code{features} elements.
  This is what's used in analysing a \code{dynamic} object without
  metapopulation structure.
}
\examples{
# create a default patch
patch <- patch(NULL)

# create a more interesting patch
# print method
print(patch(NULL))

}

